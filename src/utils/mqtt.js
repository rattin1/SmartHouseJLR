import { Client, Message } from 'paho-mqtt';

const brokerUrl = "broker.hivemq.com";
const port = 8884;
const path = "/mqtt";

// üì° T√≥picos MQTT utilizados no projeto Smart House JLR



// Quarto
const movimento = "";
const topicoLuz = "smarthouseJLR/quarto/luz";
const topicoTomada = "smarthouseJLR/quarto/tomada";
const topicoCortina = "smarthouseJLR/quarto/cortina";

// Sala
const topicoSensor = "smarthouseJLR/sala/lerSensor";
const topicoLed = "smarthouseJLR/sala/led1";
const topicoArCondicionado = "smarthouseJLR/sala/arCondicionado";
const topicoUmidificador = "smarthouseJLR/sala/umidificador";
const topicoStatusSala = "smarthouseJLR/sala/status";

// Garagem
const topicoGaragem = "smarthouseJLR/garagem";
const topicoGaragemLed = "smarthouseJLR/garagem/led";
const topicoGaragemBascular = "smarthouseJLR/garagem/bascular";
const topicoGaragemSocial = "smarthouseJLR/garagem/social";

// Gera um ID √∫nico para o cliente evita conflitos de ID
let clientID = "webClient_" + Math.floor(Math.random() * 10000);

// Cria um cliente MQTT
let client = null;

// üìä Armazenamento de dados do sensor para compartilhar com componentes
let sensorDataCallbacks = [];
let currentSensorData = { temperatura: 0, umidade: 0 };
let isConnected = false;
let reconnectInterval = null;

// üÜï Sistema de log de mensagens MQTT
let messageLogCallbacks = [];
let messageHistory = [];

// üÜï Sistema de status dos dispositivos
let deviceStatusCallbacks = [];
let currentDeviceStatus = {
  sala: {
    led: "OFF",
    arCondicionado: "OFF",
    umidificador: "OFF",
    autoAr: "OFF",
    autoUmidificador: "OFF"
  }
};

// üÜï Fun√ß√£o para componentes se inscreverem no log de mensagens
const subscribeMessageLog = (callback) => {
    messageLogCallbacks.push(callback);
    console.log("üìã Componente inscrito para receber log de mensagens");
    
    // Envia hist√≥rico existente para o novo componente
    if (messageHistory.length > 0) {
        callback(messageHistory);
    }
    
    return () => {
        messageLogCallbacks = messageLogCallbacks.filter(cb => cb !== callback);
    };
};

// üÜï Fun√ß√£o para obter hist√≥rico de mensagens
const getMessageHistory = () => messageHistory;

// üÜï Fun√ß√£o para adicionar mensagem ao log
const addToMessageLog = (topic, payload, type = 'received') => {
    const now = new Date();
    const hour = now.getHours().toString().padStart(2, "0");
    const minute = now.getMinutes().toString().padStart(2, "0");
    const time = `${hour}:${minute}`;
    
    const logEntry = {
        id: Date.now() + Math.random(), // ID √∫nico
        author: topic, // T√≥pico como autor
        text: payload, // Conte√∫do da mensagem
        time: time,
        type: type, // 'received' ou 'sent'
        timestamp: now
    };
    
    // Adiciona ao hist√≥rico (m√°ximo 100 mensagens)
    messageHistory.push(logEntry);
    if (messageHistory.length > 100) {
        messageHistory = messageHistory.slice(-100);
    }
    
    // Notifica todos os componentes inscritos
    messageLogCallbacks.forEach(callback => {
        try {
            callback([...messageHistory]); // C√≥pia do array
        } catch (error) {
            console.error("‚ùå Erro ao notificar log de mensagens:", error);
        }
    });
    
    console.log(`üìù Log adicionado: [${type}] ${topic}: ${payload}`);
};

// üÜï Fun√ß√£o para componentes se inscreverem no status dos dispositivos
const subscribeDeviceStatus = (callback) => {
    deviceStatusCallbacks.push(callback);
    console.log("üìã Componente inscrito para receber status dos dispositivos");
    
    // Envia status atual imediatamente
    callback(currentDeviceStatus);
    
    return () => {
        deviceStatusCallbacks = deviceStatusCallbacks.filter(cb => cb !== callback);
    };
};

// üÜï Fun√ß√£o para obter status atual dos dispositivos
const getCurrentDeviceStatus = () => currentDeviceStatus;

// üÜï Fun√ß√£o para atualizar status dos dispositivos
const updateDeviceStatus = (room, device, status) => {
    if (currentDeviceStatus[room]) {
        currentDeviceStatus[room][device] = status;
        
        // Notifica todos os componentes inscritos
        deviceStatusCallbacks.forEach(callback => {
            try {
                callback({ ...currentDeviceStatus });
            } catch (error) {
                console.error("‚ùå Erro ao notificar status de dispositivo:", error);
            }
        });
        
        console.log(`üìä Status atualizado: ${room}.${device} = ${status}`);
    }
};

// Fun√ß√£o para componentes se inscreverem para receber dados
const subscribeSensorData = (callback) => {
    sensorDataCallbacks.push(callback);
    console.log("üìã Componente inscrito para receber dados do sensor");
    
    // Se j√° temos dados, envia imediatamente
    if (currentSensorData.temperatura !== 0 || currentSensorData.umidade !== 0) {
        callback(currentSensorData);
    }
    
    return () => {
        sensorDataCallbacks = sensorDataCallbacks.filter(cb => cb !== callback);
    };
};

// Fun√ß√£o para obter dados atuais
const getCurrentSensorData = () => currentSensorData;

// Fun√ß√£o para verificar se est√° conectado
const isClientConnected = () => {
    return client && client.isConnected && client.isConnected();
};

// Fun√ß√£o para configurar callbacks
function setupCallbacks() {
    if (!client) return;

    // Define uma fun√ß√£o automaticamente quando a conex√£o √© perdida
    client.onConnectionLost = (responseObject) => {
        isConnected = false;
        console.error("‚ùå Conex√£o MQTT perdida:", responseObject.errorMessage);
        console.log("üîÑ Iniciando processo de reconex√£o...");
        
        // Adiciona ao log
        addToMessageLog("SISTEMA", "Conex√£o MQTT perdida", "system");
        
        // Inicia tentativas de reconex√£o
        if (!reconnectInterval) {
            reconnectInterval = setInterval(attemptReconnect, 3000);
        }
    };

    // üì• Define fun√ß√£o chamada automaticamente quando uma mensagem chega
    client.onMessageArrived = (message) => {
        console.log("üì• Mensagem recebida:", message.destinationName, message.payloadString);

        // üÜï Adiciona TODAS as mensagens ao log
        addToMessageLog(message.destinationName, message.payloadString, "received");

        // Processa dados do sensor especificamente
        if (message.destinationName === topicoSensor) {
            try {
                const dados = JSON.parse(message.payloadString);
                
                // Atualiza dados atuais
                currentSensorData = {
                    temperatura: parseFloat(dados.temperatura),
                    umidade: parseFloat(dados.umidade),
                    timestamp: new Date()
                };

                console.log("üîÑ Dados atualizados:", currentSensorData);

                // Notifica todos os componentes inscritos
                sensorDataCallbacks.forEach(callback => {
                    try {
                        callback(currentSensorData);
                        console.log("üì° Dados enviados para componente");
                    } catch (error) {
                        console.error("‚ùå Erro ao notificar componente:", error);
                    }
                });

        } catch (e) {
            // Exibe erro se o JSON estiver malformado
            console.error("‚ùå Erro ao parsear JSON:", e);
        }
    } else if (message.destinationName === topicoGaragem){
        movimento = message.payloadString; // Atualiza a vari√°vel movimento com o valor recebido
        document.getElementById("movimento").innerText = movimento;

    }
};

// üîó Conecta o cliente ao broker MQTT com SSL ativado
client.connect({
    useSSL: true, // obrigat√≥rio para conex√µes WSS (WebSocket Secure)

    // ‚úÖ Se conectar com sucesso, mostra mensagem e se inscreve nos t√≥picos
    onSuccess: () => {
        console.log("‚úÖ Conectado ao broker MQTT");
        
        // Inscreve-se nos t√≥picos para receber dados
        client.subscribe(topicoSensor); // dados do sensor DHT22
        client.subscribe(topicoGaragem) // dados do sensor de movimento DIR.
        
        console.log("üì° Inscrito nos t√≥picos de monitoramento");
    },

    // ‚ùå Se falhar ao conectar, exibe mensagem de erro
    onFailure: (err) => {
        console.error("‚ùå Falha na conex√£o:", err);
    }
});
            } catch (e) {
                console.error("‚ùå Erro ao parsear JSON:", e);
            }
        }

        // üÜï Processa status dos dispositivos da sala
        if (message.destinationName === topicoStatusSala) {
            try {
                const status = JSON.parse(message.payloadString);
                
                // Atualiza status dos dispositivos
                if (status.led !== undefined) {
                    updateDeviceStatus("sala", "led", status.led);
                }
                if (status.arCondicionado !== undefined) {
                    updateDeviceStatus("sala", "arCondicionado", status.arCondicionado);
                }
                if (status.umidificador !== undefined) {
                    updateDeviceStatus("sala", "umidificador", status.umidificador);
                }
                if (status.autoAr !== undefined) {
                    updateDeviceStatus("sala", "autoAr", status.autoAr);
                }
                if (status.autoUmidificador !== undefined) {
                    updateDeviceStatus("sala", "autoUmidificador", status.autoUmidificador);
                }

                console.log("üìä Status da sala atualizado:", status);

            } catch (e) {
                console.error("‚ùå Erro ao parsear status JSON:", e);
            }
        }
    };
}

// Fun√ß√£o para tentar reconectar
function attemptReconnect() {
    if (isConnected) {
        clearInterval(reconnectInterval);
        reconnectInterval = null;
        return;
    }

    console.log("üîÑ Tentando reconectar...");
    
    // Cria novo cliente
    clientID = "webClient_" + Math.floor(Math.random() * 10000);
    client = new Client(brokerUrl, port, path, clientID);
    
    setupCallbacks();
    
    client.connect({
        useSSL: true,
        timeout: 10,
        keepAliveInterval: 30,
        onSuccess: () => {
            isConnected = true;
            console.log("‚úÖ Reconectado ao MQTT");
            
            // Adiciona ao log
            addToMessageLog("SISTEMA", "Reconectado ao MQTT", "system");
            
            // Para o intervalo de reconex√£o
            if (reconnectInterval) {
                clearInterval(reconnectInterval);
                reconnectInterval = null;
            }
            
            // Reinscreve nos t√≥picos
            client.subscribe(topicoSensor, {
                onSuccess: () => console.log("üì° Reinscrito no t√≥pico sensor"),
                onFailure: (err) => console.error("‚ùå Falha ao se reinscrever no sensor:", err)
            });

            // üÜï Se inscreve no t√≥pico de status da sala
            client.subscribe(topicoStatusSala, {
                onSuccess: () => console.log("üì° Inscrito no t√≥pico de status da sala"),
                onFailure: (err) => console.error("‚ùå Falha ao se inscrever no status:", err)
            });
        },
        onFailure: (err) => {
            isConnected = false;
            console.error("‚ùå Falha na reconex√£o:", err);
        }
    });
}

// üîó Fun√ß√£o de inicializa√ß√£o
function initMQTT() {
    console.log("üöÄ Inicializando MQTT...");
    
    client = new Client(brokerUrl, port, path, clientID);
    setupCallbacks();
    
    client.connect({
        useSSL: true,
        timeout: 10,
        keepAliveInterval: 30,
        onSuccess: () => {
            isConnected = true;
            console.log("‚úÖ Conectado ao broker MQTT");
            
            // Adiciona ao log
            addToMessageLog("SISTEMA", "Conectado ao broker MQTT", "system");
            
            // Se inscreve no t√≥pico do sensor
            client.subscribe(topicoSensor, {
                onSuccess: () => console.log("üì° Inscrito no t√≥pico sensor"),
                onFailure: (err) => console.error("‚ùå Falha ao se inscrever no sensor:", err)
            });

            // üÜï Se inscreve no t√≥pico de status da sala
            client.subscribe(topicoStatusSala, {
                onSuccess: () => console.log("üì° Inscrito no t√≥pico de status da sala"),
                onFailure: (err) => console.error("‚ùå Falha ao se inscrever no status:", err)
            });
        },
        onFailure: (err) => {
            isConnected = false;
            console.error("‚ùå Falha na conex√£o inicial:", err);
            // Inicia tentativas de reconex√£o
            if (!reconnectInterval) {
                reconnectInterval = setInterval(attemptReconnect, 3000);
            }
        }
    });
}

// üí° Fun√ß√£o para controlar dispositivos do quarto
function controlarQuarto(dispositivo, estado) {
    let topico;
    
    switch(dispositivo) {
        case "luz":
            topico = topicoLuz;
            break;
        case "tomada":
            topico = topicoTomada;
            break;
        case "cortina":
            topico = topicoCortina;
            break;
        default:
            console.error("Dispositivo do quarto inv√°lido");
            return;
    }

    enviarComando(topico, estado);
}

// üè† Fun√ß√£o para controlar dispositivos da sala
function controlarSala(dispositivo, estado) {
    let topico;
    
    switch(dispositivo) {
        case "led":
            topico = topicoLed;
            break;
        case "arCondicionado":
            topico = topicoArCondicionado;
            break;
        case "umidificador":
            topico = topicoUmidificador;
            break;
        default:
            console.error("Dispositivo da sala inv√°lido");
            return;
    }

    enviarComando(topico, estado);
}

// üöó Fun√ß√£o para controlar dispositivos da garagem
function controlarGaragem(dispositivo, estado) {
    let topico;
    
    switch(dispositivo) {
        case "led":
            topico = topicoGaragemLed;
            break;
        case "portaoBascular":
            topico = topicoGaragemBascular;
            break;
        case "portaoSocial":
            topico = topicoGaragemSocial;
            break;
        default:
            console.error("Dispositivo da garagem inv√°lido");
            return;
    }

    enviarComando(topico, estado);
}

// üì§ Fun√ß√£o gen√©rica para enviar comandos via MQTT
function enviarComando(topico, estado) {
    // Cria a mensagem MQTT com o estado desejado
    if (!isClientConnected()) {
        console.warn("‚ö†Ô∏è Cliente n√£o conectado. Comando ser√° perdido:", topico, estado);
        addToMessageLog("SISTEMA", `Comando perdido - desconectado: ${topico} -> ${estado}`, "error");
        return;
    }

    try {
        const message = new Message(estado);
        message.destinationName = topico;
        client.send(message);
        
        // üÜï Adiciona comando enviado ao log
        addToMessageLog(topico, estado, "sent");
        
        console.log(`üì§ Enviado para ${topico}: ${estado}`);
    } catch (error) {
        console.error("‚ùå Erro ao enviar comando:", error);
        addToMessageLog("SISTEMA", `Erro ao enviar: ${topico} -> ${estado}`, "error");
    }
}

// Fun√ß√£o para obter status da conex√£o
const getConnectionStatus = () => ({
    isConnected,
    hasData: currentSensorData.temperatura !== 0 || currentSensorData.umidade !== 0
});

// üöÄ Inicializa automaticamente quando o m√≥dulo √© carregado
initMQTT();

// Exporta todas as fun√ß√µes
export {
    controlarQuarto,
    controlarSala,
    controlarGaragem,
    enviarComando,
    client
    enviarComando,
    subscribeSensorData,
    getCurrentSensorData,
    getConnectionStatus,
    subscribeMessageLog,
    getMessageHistory,
    subscribeDeviceStatus,
    getCurrentDeviceStatus
};

